import {
  Injectable,
  NotFoundException,
  BadRequestException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../../common/prisma/prisma.service';
import { Cron, CronExpression } from '@nestjs/schedule';
import {
  CreateTaskDto,
  UpdateTaskDto,
  CompleteTaskDto,
  ReassignTaskDto,
  QueryTasksDto,
  BulkAssignDto,
  AddCommentDto,
} from './dto/task.dto';
import { TaskStatus, TaskPriority, AlertSeverity, AlertCategory } from '@prisma/client';

@Injectable()
export class TasksService {
  private readonly logger = new Logger(TasksService.name);

  constructor(private prisma: PrismaService) {}

  // FR-13: Create task (can be auto-generated or manual)
  async create(createTaskDto: CreateTaskDto, autoGenerated = false) {
    // Calculate SLA deadline if slaHours provided
    let slaDeadline: Date | undefined;
    if (createTaskDto.slaHours) {
      slaDeadline = new Date();
      slaDeadline.setHours(slaDeadline.getHours() + createTaskDto.slaHours);
    }

    const task = await this.prisma.task.create({
      data: {
        ...createTaskDto,
        dueDate: new Date(createTaskDto.dueDate),
        status: TaskStatus.PENDING,
        slaDeadline,
        metadata: {
          ...(createTaskDto.metadata || {}),
          autoGenerated,
        },
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        customer: {
          select: {
            id: true,
            customerId: true,
            firstName: true,
            lastName: true,
          },
        },
        loan: {
          select: {
            id: true,
            loanId: true,
            productName: true,
          },
        },
        branch: {
          select: {
            id: true,
            code: true,
            name: true,
          },
        },
      },
    });

    this.logger.log(
      `Task created: ${task.title} [${task.priority}] - Assigned to ${task.assignedTo?.firstName || 'Unassigned'}`,
    );

    return task;
  }

  async findAll(query: QueryTasksDto) {
    const {
      page = 1,
      limit = 10,
      search,
      type,
      status,
      priority,
      assignedToId,
      customerId,
      loanId,
      branchId,
      overdue,
      slaBreached,
    } = query;
    const skip = (page - 1) * limit;

    const where: any = {};

    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } },
      ];
    }

    if (type) where.type = type;
    if (status) where.status = status;
    if (priority) where.priority = priority;
    if (assignedToId) where.assignedToId = assignedToId;
    if (customerId) where.customerId = customerId;
    if (loanId) where.loanId = loanId;
    if (branchId) where.branchId = branchId;

    if (overdue) {
      where.dueDate = { lt: new Date() };
      where.status = { in: [TaskStatus.PENDING, TaskStatus.IN_PROGRESS] };
    }

    if (slaBreached) {
      where.slaDeadline = { lt: new Date() };
      where.status = { in: [TaskStatus.PENDING, TaskStatus.IN_PROGRESS] };
    }

    const [tasks, total] = await Promise.all([
      this.prisma.task.findMany({
        where,
        skip,
        take: limit,
        orderBy: [{ priority: 'asc' }, { dueDate: 'asc' }],
        include: {
          assignedTo: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          customer: {
            select: {
              id: true,
              customerId: true,
              firstName: true,
              lastName: true,
            },
          },
          loan: {
            select: {
              id: true,
              loanId: true,
              productName: true,
              status: true,
            },
          },
          branch: {
            select: {
              id: true,
              code: true,
              name: true,
            },
          },
        },
      }),
      this.prisma.task.count({ where }),
    ]);

    return {
      data: tasks,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findOne(id: string) {
    const task = await this.prisma.task.findUnique({
      where: { id },
      include: {
        assignedTo: true,
        customer: true,
        loan: true,
        branch: true,
      },
    });

    if (!task) {
      throw new NotFoundException(`Task with ID ${id} not found`);
    }

    return task;
  }

  async update(id: string, updateTaskDto: UpdateTaskDto) {
    await this.findOne(id);

    const task = await this.prisma.task.update({
      where: { id },
      data: {
        ...updateTaskDto,
        dueDate: updateTaskDto.dueDate ? new Date(updateTaskDto.dueDate) : undefined,
      },
      include: {
        assignedTo: true,
        customer: true,
        loan: true,
      },
    });

    this.logger.log(`Task updated: ${task.title}`);

    return task;
  }

  async startTask(id: string, userId: string) {
    const task = await this.findOne(id);

    if (task.status !== TaskStatus.PENDING) {
      throw new BadRequestException('Only pending tasks can be started');
    }

    if (task.assignedToId !== userId) {
      throw new BadRequestException('Only assigned user can start this task');
    }

    const updatedTask = await this.prisma.task.update({
      where: { id },
      data: {
        status: TaskStatus.IN_PROGRESS,
        startedAt: new Date(),
      },
      include: {
        assignedTo: true,
      },
    });

    this.logger.log(`Task started: ${task.title} by user ${userId}`);

    return updatedTask;
  }

  async complete(id: string, userId: string, completeDto: CompleteTaskDto) {
    const task = await this.findOne(id);

    if (task.status === TaskStatus.COMPLETED) {
      throw new BadRequestException('Task is already completed');
    }

    if (task.assignedToId !== userId) {
      throw new BadRequestException('Only assigned user can complete this task');
    }

    const completedAt = new Date();
    const slaBreached = task.slaDeadline ? completedAt > task.slaDeadline : false;

    const updatedTask = await this.prisma.task.update({
      where: { id },
      data: {
        status: TaskStatus.COMPLETED,
        completedAt,
        completionNotes: completeDto.completionNotes,
        slaBreached,
        metadata: {
          ...(task.metadata as any),
          completedChecklist: completeDto.completedChecklist,
        },
      },
      include: {
        assignedTo: true,
      },
    });

    this.logger.log(
      `Task completed: ${task.title} by user ${userId}${slaBreached ? ' [SLA BREACHED]' : ''}`,
    );

    return updatedTask;
  }

  async reassign(id: string, reassignDto: ReassignTaskDto) {
    const task = await this.findOne(id);

    if (task.status === TaskStatus.COMPLETED || task.status === TaskStatus.CANCELLED) {
      throw new BadRequestException('Cannot reassign completed or cancelled tasks');
    }

    const updatedTask = await this.prisma.task.update({
      where: { id },
      data: {
        assignedToId: reassignDto.newAssigneeId,
        metadata: {
          ...(task.metadata as any),
          reassignmentHistory: [
            ...((task.metadata as any)?.reassignmentHistory || []),
            {
              from: task.assignedToId,
              to: reassignDto.newAssigneeId,
              reason: reassignDto.reason,
              timestamp: new Date(),
            },
          ],
        },
      },
      include: {
        assignedTo: true,
      },
    });

    this.logger.log(
      `Task reassigned: ${task.title} from ${task.assignedToId} to ${reassignDto.newAssigneeId}`,
    );

    return updatedTask;
  }

  async cancel(id: string, reason: string) {
    const task = await this.findOne(id);

    if (task.status === TaskStatus.COMPLETED) {
      throw new BadRequestException('Cannot cancel completed tasks');
    }

    const updatedTask = await this.prisma.task.update({
      where: { id },
      data: {
        status: TaskStatus.CANCELLED,
        completionNotes: `Cancelled: ${reason}`,
        completedAt: new Date(),
      },
    });

    this.logger.log(`Task cancelled: ${task.title}`);

    return updatedTask;
  }

  async bulkAssign(bulkDto: BulkAssignDto) {
    const result = await this.prisma.task.updateMany({
      where: {
        id: { in: bulkDto.taskIds },
        status: { in: [TaskStatus.PENDING, TaskStatus.IN_PROGRESS] },
      },
      data: {
        assignedToId: bulkDto.assignToId,
      },
    });

    this.logger.log(`Bulk assigned ${result.count} tasks to user ${bulkDto.assignToId}`);

    return {
      assigned: result.count,
      message: `${result.count} tasks assigned successfully`,
    };
  }

  async addComment(id: string, userId: string, commentDto: AddCommentDto) {
    const task = await this.findOne(id);

    const updatedTask = await this.prisma.task.update({
      where: { id },
      data: {
        metadata: {
          ...(task.metadata as any),
          comments: [
            ...((task.metadata as any)?.comments || []),
            {
              userId,
              comment: commentDto.comment,
              timestamp: new Date(),
            },
          ],
        },
      },
    });

    this.logger.log(`Comment added to task: ${task.title} by user ${userId}`);

    return updatedTask;
  }

  async getStatistics(userId?: string, branchId?: string) {
    const where: any = {};
    if (userId) where.assignedToId = userId;
    if (branchId) where.branchId = branchId;

    const now = new Date();

    const [
      total,
      byStatus,
      byPriority,
      overdue,
      dueSoon,
      slaBreached,
      completionRate,
    ] = await Promise.all([
      this.prisma.task.count({ where }),
      this.prisma.task.groupBy({
        by: ['status'],
        where,
        _count: true,
      }),
      this.prisma.task.groupBy({
        by: ['priority'],
        where,
        _count: true,
      }),
      this.prisma.task.count({
        where: {
          ...where,
          dueDate: { lt: now },
          status: { in: [TaskStatus.PENDING, TaskStatus.IN_PROGRESS] },
        },
      }),
      this.prisma.task.count({
        where: {
          ...where,
          dueDate: {
            gte: now,
            lte: new Date(now.getTime() + 24 * 60 * 60 * 1000), // Next 24 hours
          },
          status: { in: [TaskStatus.PENDING, TaskStatus.IN_PROGRESS] },
        },
      }),
      this.prisma.task.count({
        where: { ...where, slaBreached: true },
      }),
      this.calculateCompletionRate(where),
    ]);

    return {
      total,
      byStatus,
      byPriority,
      overdue,
      dueSoon,
      slaBreached,
      completionRate,
    };
  }

  private async calculateCompletionRate(where: any) {
    const [completed, total] = await Promise.all([
      this.prisma.task.count({
        where: { ...where, status: TaskStatus.COMPLETED },
      }),
      this.prisma.task.count({ where }),
    ]);

    return total > 0 ? (completed / total) * 100 : 0;
  }

  // FR-14 & FR-15: Monitor SLA compliance and send reminders
  @Cron(CronExpression.EVERY_30_MINUTES)
  async monitorSLAAndReminders() {
    this.logger.log('Starting SLA monitoring and reminders...');

    await Promise.all([
      this.checkSLABreaches(),
      this.sendOverdueReminders(),
      this.sendDueSoonReminders(),
    ]);

    this.logger.log('SLA monitoring and reminders completed');
  }

  // FR-14: Track SLA compliance
  private async checkSLABreaches() {
    const now = new Date();

    const tasksBreachingSLA = await this.prisma.task.findMany({
      where: {
        slaDeadline: { lt: now },
        status: { in: [TaskStatus.PENDING, TaskStatus.IN_PROGRESS] },
        slaBreached: false, // Not yet marked
      },
      include: {
        assignedTo: true,
        branch: true,
      },
    });

    for (const task of tasksBreachingSLA) {
      // Mark as SLA breached
      await this.prisma.task.update({
        where: { id: task.id },
        data: { slaBreached: true },
      });

      // Create high-severity alert
      await this.prisma.alert.create({
        data: {
          severity: AlertSeverity.HIGH,
          category: AlertCategory.OPERATIONAL,
          title: `SLA Breach - Task Overdue`,
          message: `Task "${task.title}" has breached SLA deadline. Assigned to: ${task.assignedTo?.firstName} ${task.assignedTo?.lastName}`,
          assignedToId: task.assignedToId,
          branchId: task.branchId,
          requiresAction: true,
          source: 'SLA_MONITOR',
          metadata: {
            taskId: task.id,
            slaDeadline: task.slaDeadline,
            actualTime: now,
          },
        },
      });

      this.logger.warn(`SLA breach detected for task: ${task.title}`);
    }
  }

  // FR-15: Send reminders for overdue tasks
  private async sendOverdueReminders() {
    const now = new Date();

    const overdueTasks = await this.prisma.task.findMany({
      where: {
        dueDate: { lt: now },
        status: { in: [TaskStatus.PENDING, TaskStatus.IN_PROGRESS] },
      },
      include: {
        assignedTo: true,
      },
    });

    for (const task of overdueTasks) {
      const daysPastDue = Math.floor(
        (now.getTime() - task.dueDate.getTime()) / (1000 * 60 * 60 * 24),
      );

      // Send reminder every 3 days for overdue tasks
      if (daysPastDue % 3 === 0) {
        await this.prisma.alert.create({
          data: {
            severity: AlertSeverity.MEDIUM,
            category: AlertCategory.OPERATIONAL,
            title: `Task Overdue - ${daysPastDue} days`,
            message: `Task "${task.title}" is ${daysPastDue} days overdue. Please complete urgently.`,
            assignedToId: task.assignedToId,
            branchId: task.branchId,
            requiresAction: true,
            source: 'TASK_REMINDER',
            metadata: {
              taskId: task.id,
              daysPastDue,
              priority: task.priority,
            },
          },
        });

        this.logger.log(`Overdue reminder sent for task: ${task.title} (${daysPastDue} days)`);
      }
    }
  }

  // FR-15: Send reminders for tasks due soon
  private async sendDueSoonReminders() {
    const now = new Date();
    const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);

    const tasksDueSoon = await this.prisma.task.findMany({
      where: {
        dueDate: {
          gte: now,
          lte: tomorrow,
        },
        status: { in: [TaskStatus.PENDING, TaskStatus.IN_PROGRESS] },
        priority: { in: [TaskPriority.HIGH, TaskPriority.URGENT] },
      },
      include: {
        assignedTo: true,
      },
    });

    for (const task of tasksDueSoon) {
      // Check if reminder already sent today
      const existingReminder = await this.prisma.alert.findFirst({
        where: {
          title: { contains: 'Task Due Soon' },
          metadata: {
            path: ['taskId'],
            equals: task.id,
          },
          createdAt: { gte: new Date(now.setHours(0, 0, 0, 0)) },
        },
      });

      if (!existingReminder) {
        await this.prisma.alert.create({
          data: {
            severity: AlertSeverity.LOW,
            category: AlertCategory.OPERATIONAL,
            title: `Task Due Soon - ${task.priority}`,
            message: `Task "${task.title}" is due within 24 hours. Please prioritize.`,
            assignedToId: task.assignedToId,
            branchId: task.branchId,
            requiresAction: false,
            source: 'TASK_REMINDER',
            metadata: {
              taskId: task.id,
              dueDate: task.dueDate,
              priority: task.priority,
            },
          },
        });

        this.logger.log(`Due soon reminder sent for task: ${task.title}`);
      }
    }
  }

  async remove(id: string) {
    await this.findOne(id);

    await this.prisma.task.delete({
      where: { id },
    });

    this.logger.log(`Task deleted: ${id}`);

    return { message: 'Task deleted successfully' };
  }
}
